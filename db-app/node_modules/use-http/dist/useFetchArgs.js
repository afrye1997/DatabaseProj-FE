"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var utils_1 = require("./utils");
var react_1 = require("react");
var FetchContext_1 = __importDefault(require("./FetchContext"));
var defaults_1 = __importDefault(require("./defaults"));
var useField = function (field, urlOrOptions, optionsNoURLs) {
    var context = react_1.useContext(FetchContext_1.default);
    var contextOptions = context.options || {};
    return react_1.useMemo(function () {
        if (utils_1.isObject(urlOrOptions) && field in urlOrOptions)
            return urlOrOptions[field];
        if (utils_1.isObject(optionsNoURLs) && field in optionsNoURLs) {
            return optionsNoURLs[field];
        }
        if (field in contextOptions)
            return contextOptions[field];
        return defaults_1.default[field];
    }, [urlOrOptions, field, optionsNoURLs, contextOptions]);
};
function useFetchArgs(urlOrOptionsOrOverwriteGlobal, optionsNoURLsOrOverwriteGlobalOrDeps, deps) {
    var context = react_1.useContext(FetchContext_1.default);
    context.options = react_1.useMemo(function () {
        var overwriteGlobalOptions = (utils_1.isFunction(urlOrOptionsOrOverwriteGlobal) ? urlOrOptionsOrOverwriteGlobal : utils_1.isFunction(optionsNoURLsOrOverwriteGlobalOrDeps) && optionsNoURLsOrOverwriteGlobalOrDeps);
        if (!overwriteGlobalOptions)
            return context.options;
        // make a copy so we make sure not to modify the original context
        return overwriteGlobalOptions(__assign({}, context.options));
    }, [context.options, optionsNoURLsOrOverwriteGlobalOrDeps, urlOrOptionsOrOverwriteGlobal]);
    var urlOrOptions = urlOrOptionsOrOverwriteGlobal;
    var optionsNoURLs = optionsNoURLsOrOverwriteGlobalOrDeps;
    utils_1.invariant(!(utils_1.isObject(urlOrOptions) && utils_1.isObject(optionsNoURLs)), 'You cannot have a 2nd parameter of useFetch when your first argument is an object config.');
    var url = react_1.useMemo(function () {
        if (utils_1.isString(urlOrOptions) && urlOrOptions)
            return urlOrOptions;
        if (utils_1.isObject(urlOrOptions) && !!urlOrOptions.url)
            return urlOrOptions.url;
        if (context.url)
            return context.url;
        return defaults_1.default.url;
    }, [context.url, urlOrOptions]);
    utils_1.invariant(!!url, 'The first argument of useFetch is required unless you have a global url setup like: <Provider url="https://example.com"></Provider>');
    var dependencies = react_1.useMemo(function () {
        if (Array.isArray(optionsNoURLsOrOverwriteGlobalOrDeps))
            return optionsNoURLsOrOverwriteGlobalOrDeps;
        if (Array.isArray(deps))
            return deps;
        return defaults_1.default.dependencies;
    }, [optionsNoURLsOrOverwriteGlobalOrDeps, deps]);
    var data = useField('data', urlOrOptions, optionsNoURLs);
    var path = useField('path', urlOrOptions, optionsNoURLs);
    var timeout = useField('timeout', urlOrOptions, optionsNoURLs);
    var persist = useField('persist', urlOrOptions, optionsNoURLs);
    var onAbort = useField('onAbort', urlOrOptions, optionsNoURLs);
    var onTimeout = useField('onTimeout', urlOrOptions, optionsNoURLs);
    var onNewData = useField('onNewData', urlOrOptions, optionsNoURLs);
    var perPage = useField('perPage', urlOrOptions, optionsNoURLs);
    var cachePolicy = useField('cachePolicy', urlOrOptions, optionsNoURLs);
    var cacheLife = useField('cacheLife', urlOrOptions, optionsNoURLs);
    utils_1.invariant(Number.isInteger(cacheLife) && cacheLife >= 0, '`cacheLife` must be a number >= 0');
    var suspense = useField('suspense', urlOrOptions, optionsNoURLs);
    var retries = useField('retries', urlOrOptions, optionsNoURLs);
    utils_1.invariant(Number.isInteger(retries) && retries >= 0, '`retries` must be a number >= 0');
    var retryOn = useField('retryOn', urlOrOptions, optionsNoURLs);
    var isValidRetryOn = utils_1.isFunction(retryOn) || (Array.isArray(retryOn) && retryOn.every(utils_1.isPositiveNumber));
    utils_1.invariant(isValidRetryOn, '`retryOn` must be an array of positive numbers or a function returning a boolean.');
    var retryDelay = useField('retryDelay', urlOrOptions, optionsNoURLs);
    utils_1.invariant(utils_1.isFunction(retryDelay) || Number.isInteger(retryDelay) && retryDelay >= 0, '`retryDelay` must be a positive number or a function returning a positive number.');
    var responseType = useField('responseType', urlOrOptions, optionsNoURLs);
    var loading = react_1.useMemo(function () {
        if (utils_1.isObject(urlOrOptions))
            return !!urlOrOptions.loading || Array.isArray(dependencies);
        if (utils_1.isObject(optionsNoURLs))
            return !!optionsNoURLs.loading || Array.isArray(dependencies);
        return defaults_1.default.loading || Array.isArray(dependencies);
    }, [urlOrOptions, dependencies, optionsNoURLs]);
    var interceptors = react_1.useMemo(function () {
        var contextInterceptors = context.options && (context.options.interceptors || {});
        var final = __assign({}, contextInterceptors);
        if (utils_1.isObject(urlOrOptions) && utils_1.isObject(urlOrOptions.interceptors)) {
            if (urlOrOptions.interceptors.request)
                final.request = urlOrOptions.interceptors.request;
            if (urlOrOptions.interceptors.response)
                final.response = urlOrOptions.interceptors.response;
        }
        if (utils_1.isObject(optionsNoURLs) && utils_1.isObject(optionsNoURLs.interceptors)) {
            if (optionsNoURLs.interceptors.request)
                final.request = optionsNoURLs.interceptors.request;
            if (optionsNoURLs.interceptors.response)
                final.response = optionsNoURLs.interceptors.response;
        }
        return final;
    }, [context.options, urlOrOptions, optionsNoURLs]);
    var requestInit = react_1.useMemo(function () {
        var contextRequestInit = utils_1.pullOutRequestInit(context.options);
        var requestInitOptions = utils_1.isObject(urlOrOptions)
            ? urlOrOptions
            : utils_1.isObject(optionsNoURLs)
                ? optionsNoURLs
                : {};
        var requestInit = utils_1.pullOutRequestInit(requestInitOptions);
        return __assign(__assign(__assign({}, contextRequestInit), requestInit), { headers: __assign(__assign(__assign({}, defaults_1.default.headers), contextRequestInit.headers), requestInit.headers) });
    }, [context.options, urlOrOptions, optionsNoURLs]);
    return {
        customOptions: {
            cacheLife: cacheLife,
            cachePolicy: cachePolicy,
            interceptors: interceptors,
            onAbort: onAbort,
            onNewData: onNewData,
            onTimeout: onTimeout,
            path: path,
            persist: persist,
            perPage: perPage,
            responseType: responseType,
            retries: retries,
            retryDelay: retryDelay,
            retryOn: retryOn,
            suspense: suspense,
            timeout: timeout,
            url: url,
        },
        requestInit: requestInit,
        defaults: {
            data: data,
            loading: loading
        },
        dependencies: dependencies
    };
}
exports.default = useFetchArgs;
